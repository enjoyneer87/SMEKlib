# (c) Dionysios Aliprantis and Oleg Wasynczuk
# Electric Machines: Theory and Analysis Using the 
#    Finite Element Method
# This file contains several useful functions for FEA that
# appear in Chapter 3 (i.e., basic FEA building blocks).

import numpy as np
import scipy.sparse as sps
import scipy.sparse.linalg as spsl
from math import pi
import matplotlib.pyplot as plt
from matplotlib.tri import Triangulation
import scipy.interpolate as spi


# see Section 3.3.1, p. 241
def my_loadtxt(filename, N, rowlength, delimiter=',', 
                 skiprows=0, dtype=float):
    """
    Simple CSV file reader.
    """
    
    def iter_func():
        with open(filename, 'r') as infile:
            for _ in range(skiprows):
                next(infile)
            for line in infile:
                if line[0] == '#':
                    next(infile)
                else:
                    line = line.rstrip().split(delimiter)
                    for item in line:
                        yield dtype(item)

    data = np.fromiter(iter_func(), dtype=dtype, count=N).\
                reshape((-1, rowlength))
    return data
    
    
# see Section 3.3.1, p. 240
def load_mesh(fname, iter_no=1):
    """
    Loads & returns nodes and triangles (as NumPy arrays) 
    from files generated by Triangle. Also returns number of 
    nodes and triangles.
    """

    nodes_fname = fname + '.{}.node'.format(iter_no)
    ele_fname = fname + '.{}.ele'.format(iter_no)
    edge_fname = fname + '.{}.edge'.format(iter_no)

    # load nodes 
    with open(nodes_fname,'r') as f:
        line = f.readline().rstrip().split()
        n_nodes = int(line[0])
        n_attr = int(line[2])
        n_bm = int(line[3])
        N = n_nodes*(3 + n_attr + n_bm)
    nodes = iter_loadtxt(nodes_fname, N=N, delimiter=None,\
                         skiprows=1, rowlength=3+n_attr+n_bm)
        
    # load triangles 
    with open(ele_fname,'r') as f:
        line = f.readline().rstrip().split()
        n_tri = int(line[0])
        N = n_tri*5
    triangles = iter_loadtxt(ele_fname, N=N, delimiter=None,\
                             dtype=int, skiprows=1, rowlength=5)
                             
    # load edges
    with open(edge_fname,'r') as f:
        line = f.readline().rstrip().split()
        n_edges = int(line[0])
        N = n_edges*4
    edges = iter_loadtxt(edge_fname, N=N, delimiter=None,\
                             dtype=int, skiprows=1, rowlength=4)
        
    return n_nodes, nodes, n_tri, triangles, n_edges, edges
    

# see Section 3.3.2, p. 243
def calculate_pqrDeltaSk(n_tri, nodes, triangles):
    """
    Calculates areas (delta) and p,q,r for all triangles. 
    Also calculates the element stiffness matrix
    Sk = (q*q.T + r*r.T)/(4 * delta) 
    for all triangles. For each element, we save the vector 
    (exploiting symmetry): 
    Sk = [s11 s12 s13 s22 s23 s33]  
    """    
    
    delta = np.zeros(n_tri)
    p = np.zeros((n_tri,3))
    q = np.zeros((n_tri,3))
    r = np.zeros((n_tri,3))
    Sk = np.zeros((n_tri,6))

    for k in range(n_tri):
        l = triangles[k,1]-1
        m = triangles[k,2]-1
        n = triangles[k,3]-1
        
        x1 = nodes[l,1]
        y1 = nodes[l,2]
        x2 = nodes[m,1]
        y2 = nodes[m,2]
        x3 = nodes[n,1]
        y3 = nodes[n,2]

        p[k,0] = x2*y3 - x3*y2
        q[k,0] = q1 = y2 - y3
        r[k,0] = r1 = x3 - x2
        p[k,1] = x3*y1 - x1*y3
        q[k,1] = q2 = y3 - y1
        r[k,1] = r2 = x1 - x3
        p[k,2] = x1*y2 - x2*y1
        q[k,2] = q3 = -q[k,0] - q[k,1]
        r[k,2] = r3 = -r[k,0] - r[k,1]

        # here we rely on the fact that Triangle generates 
        # triangles with nodes listed in ccw order (so that 
        # the area will turn out positive)
        delta[k] = dlt = 0.5 * (r3*q2 - q3*r2)  

        Sk[k,0] = (q1*q1 + r1*r1)/4/dlt
        Sk[k,1] = (q1*q2 + r1*r2)/4/dlt
        Sk[k,2] = (q1*q3 + r1*r3)/4/dlt
        Sk[k,3] = (q2*q2 + r2*r2)/4/dlt
        Sk[k,4] = (q2*q3 + r2*r3)/4/dlt
        Sk[k,5] = (q3*q3 + r3*r3)/4/dlt
        
    return p, q, r, delta, Sk


# see Section 3.3.2, p. 244
def build_S_matrix(n_tri, n_nodes, triangles, Sk, nu, J, delta):
    """
    Builds global sparse (symmetric) S-matrix.
    """
    
    row = np.zeros(9*n_tri, dtype = int)
    col = np.zeros(9*n_tri, dtype = int)
    s = np.zeros(9*n_tri)
    b = np.zeros(n_nodes)  
    count = 0
    
    for k in range(n_tri):
        gamma = nu[k]
        
        l = triangles[k,1]-1
        m = triangles[k,2]-1
        n = triangles[k,3]-1
    
        row[count] = l
        col[count] = l
        s[count] = gamma * Sk[k,0] 
        count += 1

        row[count] = l
        col[count] = m
        tmp = gamma * Sk[k,1]  
        s[count] = tmp
        count += 1
        row[count] = m
        col[count] = l
        s[count] = tmp
        count += 1

        row[count] = l
        col[count] = n
        tmp = gamma * Sk[k,2]
        s[count] = tmp
        count += 1
        row[count] = n
        col[count] = l
        s[count] = tmp
        count += 1

        row[count] = m
        col[count] = m
        s[count] = gamma * Sk[k,3] 
        count += 1

        row[count] = n
        col[count] = m
        tmp = gamma * Sk[k,4]
        s[count] = tmp
        count += 1
        row[count] = m
        col[count] = n
        s[count] = tmp
        count += 1

        row[count] = n
        col[count] = n
        s[count] = gamma * Sk[k,5]
        count += 1

        t = J[k]*delta[k]/3
        b[l] += t
        b[m] += t
        b[n] += t

        
    S = sps.coo_matrix((s, (row,col)), \
                  shape=(n_nodes,n_nodes)).tocsc()
    return S, b


# see Section 3.3.3, p. 253
def make_triangulation(nodes, triangles):
    """
    Builds a matplotlib.tri.Triangulation
    """
    x = nodes[:,1]
    y = nodes[:,2]
    tr = triangles[:,1:4]-1
    return Triangulation(x,y,tr)
    

# see Section 3.3.3, p. 252
# Note: This plotting routine is specific to the square-core inductor example.
#       It can be modified to accommodate other, more complex geometries.
def plot_mesh():
    C = np.ones(n_tri)
    C[ind_st-1] = 0.8
    C[ind_coil-1] = 0.6
    plt.tripcolor(triangulation,C,edgecolors='0.9',\
                          cmap=plt.cm.gray,vmin=0.0,vmax=1.0)


# see Section 3.3.3, p. 253
def plot_flux_lines(Nlines = 10):
    plt.tricontour(triangulation,A,Nlines,colors='k')   


# see Section 3.6.1, p. 283
# Note: This version is slightly modified from what is in the text. 
#       It accepts an optional stacking factor as a parameter, based on 
#       Example 3.8, p. 291.
def load_BH_curve_pchip(fname='hb.txt', k_stack=1):
    mu0 = 4e-7*pi
    hb = np.loadtxt(fname)
    Hdat = hb[:,0]
    Bdat = k_stack*hb[:,1] + (1-k_stack)*mu0*Hdat    
    nudat = np.divide(Hdat,Bdat)
   
    Hmax = Hdat[-1]
    Bmax = Bdat[-1]
    B1 = Bdat[0]
    H1 = Hdat[0]
    m1 = 0.5*B1*H1 # field energy density at H1(B1) 
    assert B1 > 0, \
        'First B point of BH curve is not strictly positive'
        
    Bsqdat = Bdat**2
    
    nuB2_intrpl = spi.PchipInterpolator(Bsqdat,nudat)
    dnudB2_intrpl = nuB2_intrpl.derivative()
    int_nu_intrpl = nuB2_intrpl.antiderivative()
                                   
    return nuB2_intrpl, dnudB2_intrpl, int_nu_intrpl,\
        Bmax, B1, m1


# see Section 3.6.1, p. 283
# Note: This function does not appear in the textbook; however, it corresponds
#       to the calculations described in Section 3.6.1. 
def nu_of_Bsq(Bsq, Bmax, B1, m1, nu_intrpl, dnu_intrpl=None, int_nu_intrpl=None):
    """
    Evaluates inverse magnetic permeability (nu) and other related quantities 
    based on interpolation of BH data for a ferromagnetic material.
    
    Inputs:
    nu_intrpl:      PCHIP structure for nu(B^2)
    dnu_intrpl:     PCHIP structure for dnu/d(B^2) [optional]
    int_nu_intrpl:  PCHIP structure for int_(B1^2)^(B^2) nu(b^2) d(b^2) [opt.]
    Bsq = B^2:      scalar or array containing B-field values for evaluations
    Bmax:           B-field value after which a linear extrapolation of 
                    the B-H curve is imposed.
    B1:             B-field value before which the BH curve increases linearly 
                    from the origin.
    m1:             Integration constant for energy density (value at B1)
    
    Outputs:
    nu(Bsq)
    dnudB2(Bsq)
    m(Bsq)
    """             

    mu0 = 4e-7*pi
    nu = np.empty(Bsq.size, dtype = float)
    dnudB2 = np.empty(Bsq.size, dtype = float)
    m = np.empty(Bsq.size, dtype = float)
    
    Bmaxsq = Bmax**2
    B1sq = B1**2
    nu1 = 2*m1/B1sq
    
    # data below B1
    ind = (Bsq < B1sq)
    nu[ind] = nu1
    if dnu_intrpl is not None:
        dnudB2[ind] = 0.0
    if int_nu_intrpl is not None:
        m[ind] = 0.5*Bsq[ind]*nu1
        
    # data between B1 and Bmax
    ind = np.logical_and(Bsq <= Bmaxsq, Bsq >= B1sq)
    nu[ind] = nu_intrpl.__call__(Bsq[ind])
    if dnu_intrpl is not None:
        dnudB2[ind] = dnu_intrpl.__call__(Bsq[ind])
    if int_nu_intrpl is not None:
        m[ind] = m1 + 0.5*int_nu_intrpl.__call__(Bsq[ind])
        
    # data above Bmax
    ind = (Bsq > Bmaxsq)
    if len(ind) > 0:
        Hmax = nu_intrpl.__call__(Bmaxsq)*Bmax
        B = np.sqrt(Bsq[ind])
        H = Hmax + (1/mu0)*(B - Bmax)
        nu[ind] = np.divide(H,B)
        if dnu_intrpl is not None:
            dnudB2[ind] = (-Hmax + Bmax/mu0)/2/np.power(B,3)
        if int_nu_intrpl is not None:    
            m[ind] = m1 + 0.5*int_nu_intrpl.__call__(Bmaxsq) + \
                     Hmax*(B - Bmax) + np.power(B - Bmax,2)/2/mu0

    return nu, dnudB2, m
    

# see Section 3.6.2, p. 288
def build_grad_Hess(n_tri, n_nodes, triangles, Sk, A, J, delta, nu, dnu):
    """
    Builds gradient (vector) and Hessian (matrix) of the functional.
    """

    g = np.zeros(n_nodes, dtype = float)
    row = np.zeros(9*n_tri, dtype = int)
    col = np.zeros(9*n_tri, dtype = int)
    h = np.zeros(9*n_tri, dtype = np.float)
    count = 0
    
    for k in range(n_tri):
        
        s11 = Sk[k,0]
        s12 = Sk[k,1]
        s13 = Sk[k,2]        
        s22 = Sk[k,3]
        s23 = Sk[k,4]
        s33 = Sk[k,5]
        
        l = triangles[k,1]-1
        m = triangles[k,2]-1
        n = triangles[k,3]-1
    
        A1 = A[l]
        A2 = A[m]
        A3 = A[n]
        
        dlt = delta[k]
        t = J[k]*dlt/3
        nuk = nu[k]
        dnuk = dnu[k]
        
        # elements of Sk*Ak
        SA1 = s11*A1 + s12*A2 + s13*A3
        SA2 = s12*A1 + s22*A2 + s23*A3
        SA3 = s13*A1 + s23*A2 + s33*A3
        
        # gradient
        g[l] += nuk*SA1 - t 
        g[m] += nuk*SA2 - t 
        g[n] += nuk*SA3 - t 
    
        # Hessian
        gamma = 2/dlt*dnuk
        
        row[count] = l
        col[count] = l
        h[count] = nuk*s11 + gamma * SA1*SA1 
        count += 1

        row[count] = l
        col[count] = m
        tmp = nuk*s12 + gamma * SA1*SA2  
        h[count] = tmp
        count += 1
        row[count] = m
        col[count] = l
        h[count] = tmp
        count += 1

        row[count] = l
        col[count] = n
        tmp = nuk*s13 + gamma * SA1*SA3 
        h[count] = tmp
        count += 1
        row[count] = n
        col[count] = l
        h[count] = tmp
        count += 1

        row[count] = m
        col[count] = m
        h[count] = nuk*s22 + gamma * SA2*SA2 
        count += 1

        row[count] = n
        col[count] = m
        tmp = nuk*s23 + gamma * SA2*SA3
        h[count] = tmp
        count += 1
        row[count] = m
        col[count] = n
        h[count] = tmp
        count += 1

        row[count] = n
        col[count] = n
        h[count] = nuk*s33 + gamma * SA3*SA3 
        count += 1
        
    return g, sps.coo_matrix((h, (row,col)), shape=(n_nodes,n_nodes)).tocsc()
    


